// myant.cpp : 定义控制台应用程序的入口点。
//

// AO.cpp : 定义控制台应用程序的入口点。
#pragma once

#include <iostream>
#include <math.h> 
#include <time.h>

const double ALPHA=2.0; //启发因子，信息素的重要程度
const double BETA=3.0;   //期望因子，城市间距离的重要程度
const double ROU=0.95; //信息素残留参数
//新增1
const double CHANGE=0.2;//变异概率

const int N_ANT_COUNT=5; //蚂蚁数量
const int N_IT_COUNT=100; //迭代次数
const int N_POINT_COUNT=20; //城市数量

const int N_POINT_NO[N_POINT_COUNT]={0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19};
const int N_POINT_SELF_ID[N_POINT_COUNT]={0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19};//节点自身ID
const int N_START_POINT_SELF_ID=2 ;  //出发城市ID
const int N_END_POINT_SELF_ID= 19;  //终点城市ID
const int N_INCLUDING_SELF_ID[]={3,5,7,11,13,17};        //必经节点ID

const double DBQ=100.0; //总的信息素
const double DB_MAX=10e9; //一个标志数，10的9次方

double g_Trial[N_POINT_COUNT][N_POINT_COUNT]; //两两城市间信息素，就是环境信息素
double g_Cost[N_POINT_COUNT][N_POINT_COUNT]={
//    0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19
	{-1,-1,-1,-1, 8,-1,-1,-1,17,-1,-1,-1,-1,15,-1,-1,-1,-1,-1, 1},//0
	{ 4,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},//1
	{-1,-1,-1,20,-1,-1,-1,-1,-1,19,-1,-1,-1,-1,-1, 8,-1,-1,-1,-1},//2
	{14,-1,-1,-1,-1,20,-1,-1,-1,-1,-1,12,-1,-1,-1,-1,-1,-1,-1,-1},//3
	{-1,15,-1,-1,-1,17,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},//4
	{-1,-1,-1,-1,-1,-1, 2,20,18,14,-1,-1,-1,-1,-1,-1,-1,-1,-1,20},//5
	{-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 4,-1,-1},//6
	{-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,20,-1, 1,-1,-1,19,-1,-1,-1},//7
	{-1,-1,-1,-1,-1,-1, 1,-1,-1,-1,-1,-1,17,-1,-1,-1,-1,-1,-1,-1},//8
	{-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,11,-1,-1,-1,-1,-1},//9
	{-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 1,-1,-1,-1,-1,-1,-1,-1},//10
	{-1,-1,-1,-1, 7,-1,-1,12,-1,-1,-1,-1,-1,20,-1,-1,-1,-1,-1,20},//11
	{-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 5,-1,-1,-1,-1,-1},//12
	{-1,-1,-1,-1, 2,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,12,-1,-1},//13
	{-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 9},//14
	{-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,14,-1,-1,-1,-1,-1,-1,-1, 2,-1},//15
	{-1,-1,-1,-1,-1,-1,-1,-1, 1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},//16
	{-1,-1,-1,-1,-1,20,-1,-1,-1,14,-1,20,-1,-1,-1,-1,-1,-1,10, 3},//17
	{-1,-1,-1, 8,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 8,-1,-1,-1,-1},//18
	{-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,12,-1} //19
//    0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19
}; //两两城市间距离

//eil51.tsp城市坐标数据


//返回指定范围内的随机整数
int rnd(int nLow,int nUpper)
{
    return nLow+(nUpper-nLow)*rand()/(RAND_MAX+1);
}

//返回指定范围内的随机浮点数
double rnd(double dbLow,double dbUpper)
{
    //double dbTemp=rand()%(10000)/(double)(10000);
	double dbTemp=rand()/((double)RAND_MAX+1.0);
    return dbLow+dbTemp*(dbUpper-dbLow);
}

//返回浮点数四舍五入取整后的浮点数
double ROUND(double dbA)
{
    return (double)((int)(dbA+0.5));
}





//定义蚂蚁类
class CAnt
{
public:
    CAnt(void);
    ~CAnt(void);

public:

	int m_nPath[N_POINT_COUNT]; //蚂蚁走的自身ID路径
	int m_nPath_No[N_POINT_COUNT]; //蚂蚁编号路径
    double m_dbPathLength; //蚂蚁走过的路径长度

    int m_nAllowedPoint[N_POINT_COUNT]; //没去过的城市
    int m_nCurPointNo; //当前所在城市编号
    int m_nMovedPointCount; //已经去过的城市数量
	int end_NO;//终点城市编号
	bool Stop_Flag;
	bool Back_Flag;
	bool Death_Flag;

public:

    int ChooseNextPoint(); //选择下一个城市
    void Init(); //初始化
    void Move(); //蚂蚁在城市间移动
    void Search(); //搜索路径
    void CalPathLength(); //计算蚂蚁走过的路径长度

};

//构造函数
CAnt::CAnt(void)
{
}

//析构函数
CAnt::~CAnt(void)
{
}





//初始化函数，蚂蚁搜索前调用
void CAnt::Init()
{
	for(int i=0;i<N_POINT_COUNT;i++)
	{
		if(N_POINT_SELF_ID[i]==N_START_POINT_SELF_ID)
		{
			m_nCurPointNo=i;
			//break;
		}
		if(N_POINT_SELF_ID[i]==N_END_POINT_SELF_ID)
		{
			end_NO=i;
		}
		
	}

    for (int i=0;i<N_POINT_COUNT;i++)
    {
		if(i==end_NO)
		{
			m_nAllowedPoint[i]=0;
		}
		else
		{
			m_nAllowedPoint[i]=1; //设置全部城市为没有去过
		}
        m_nPath[i]=-1; //蚂蚁走的路径全部设置为0
		m_nPath_No[i]=-1;
    }

    //蚂蚁走过的路径长度设置为0
    m_dbPathLength=0.0; 

    //随机选择一个出发城市
	
    //m_nCurPointNo=N_START_POINT_SELF_ID;
    //把出发城市保存入路径数组中
	m_nPath_No[0]=m_nCurPointNo;
    m_nPath[0]=N_START_POINT_SELF_ID;

    //标识出发城市为已经去过了
    m_nAllowedPoint[m_nCurPointNo]=0; 

    //已经去过的城市数量设置为1
    m_nMovedPointCount=1; 
	Stop_Flag=false;
	

	Back_Flag=false;

	Death_Flag=false;
}

//选择下一个城市
//返回值 为城市编号
int CAnt::ChooseNextPoint()
{
	//新增2
    int nSelectedPoint=-1; //返回结果，先暂时把其设置为-1
	double ChangeProb=0.0;
    //==============================================================================
    //计算当前城市和没去过的城市之间的信息素总和
    
    double dbTotal=0.0;    
    double prob[N_POINT_COUNT]; //保存各个城市被选中的概率
	ChangeProb=rnd(0.0,1.0);
    for (int i=0;i<N_POINT_COUNT;i++)
    {
        if ((m_nAllowedPoint[i] == 1) && (g_Cost[m_nCurPointNo][i]!=-1)) //城市没去过
        {
            prob[i]=pow(g_Trial[m_nCurPointNo][i],ALPHA)*pow(1.0/g_Cost[m_nCurPointNo][i],BETA); //该城市和当前城市间的信息素
            dbTotal=dbTotal+prob[i]; //累加信息素，得到总和
        }
        else //如果城市去过了，则其被选中的概率值为0
        {
            prob[i]=0.0;
        }
    }

	bool flag=true;
	int no1=0;
	double a=0.0,b=0.0;

	if(ChangeProb<CHANGE)
	{
		for (int i=0;i<N_POINT_COUNT;i++)
		{
			if(prob[i]!=0.0)
			{
				if(flag)
				{
					no1=i;
					flag=false;
				}
				a=prob[i];
				prob[i]=b;
				b=a;
			}	
		}
		prob[no1]=b;
	}
	
	for(int i=0;i<N_POINT_COUNT;i++)
	{
		if(prob[i]>0)
		{
			break;
		}
		if(i==N_POINT_COUNT-1)
		{
	
			//Stop_Flag=true;
			Back_Flag=true;
		}
	}

    //==============================================================================
    //进行轮盘选择
    double dbTemp=0.0;
	
    if ((dbTotal > 0.0)&&(Stop_Flag==false)) //总的信息素值大于0
    {
		//srand(time(NULL));
        dbTemp=rnd(0.0,dbTotal); //取一个随机数

        for (int i=0;i<N_POINT_COUNT;i++)
        {
            if ((m_nAllowedPoint[i] == 1) && (g_Cost[m_nCurPointNo][i]!=-1)) //城市没去过
            {
                dbTemp=dbTemp-prob[i]; //这个操作相当于转动轮盘，如果对轮盘选择不熟悉，仔细考虑一下
                if (dbTemp < 0.0) //轮盘停止转动，记下城市编号，直接跳出循环
				{
                    nSelectedPoint=i;
                    break;
                }
            }
        }
    }

    //==============================================================================
    //如果城市间的信息素非常小 ( 小到比double能够表示的最小的数字还要小 )
    //那么由于浮点运算的误差原因，上面计算的概率总和可能为0
    //会出现经过上述操作，没有城市被选择出来
    //出现这种情况，就把第一个没去过的城市作为返回结果
    
    //题外话：刚开始看的时候，下面这段代码困惑了我很长时间，想不通为何要有这段代码，后来才搞清楚。
    
	
    //==============================================================================
    //返回结果，就是城市的编号
    return nSelectedPoint;
}





//蚂蚁在城市间移动
void CAnt::Move()
{

	bool flag=false;
	for(int i=0;i<sizeof(N_INCLUDING_SELF_ID)/sizeof(N_INCLUDING_SELF_ID[0]);i++)
	{
		for(int j=0;j<N_POINT_COUNT;j++)
		{
			if(N_INCLUDING_SELF_ID[i]==m_nPath[j])
			{
				break;
			}
			if(j==N_POINT_COUNT-1)
			{
				flag=true;
			}
			
		}
		if(flag)
		{
			break;
		}
		if(i==sizeof(N_INCLUDING_SELF_ID)/sizeof(N_INCLUDING_SELF_ID[0])-1)
		{
			m_nAllowedPoint[end_NO]=1;
		}
	}
    int nPointNo=ChooseNextPoint(); //选择下一个城市
	if(nPointNo==end_NO)
	{
		Stop_Flag=true;
	}
	
	if(Back_Flag==false)
	{
		
	
		m_nPath_No[m_nMovedPointCount]=nPointNo;
		m_nPath[m_nMovedPointCount]=N_POINT_SELF_ID[nPointNo];
		/*
		for(int i=0;i<N_POINT_COUNT;i++)
		{
			if(N_POINT_NO[i]==nPointNo)
			{
				m_nPath[m_nMovedPointCount]=N_POINT_SELF_ID;
				break;
			}
		}
		*/
		//m_nPath[m_nMovedPointCount]=nPointNo; //保存蚂蚁走的路径
		m_nAllowedPoint[nPointNo]=0;//把这个城市设置成已经去过了
		m_nCurPointNo=nPointNo; //改变当前所在城市为选择的城市
		m_nMovedPointCount++; //已经去过的城市数量加1
		
		
	}
	else
	{
		m_nAllowedPoint[m_nPath_No[m_nMovedPointCount-1]]=0;
		for(int i=0;i<sizeof(N_INCLUDING_SELF_ID)/sizeof(N_INCLUDING_SELF_ID[0]);i++)
		{
			if(N_POINT_SELF_ID[m_nPath_No[m_nMovedPointCount-1]]==N_INCLUDING_SELF_ID[i])
			{
				m_nAllowedPoint[m_nPath_No[m_nMovedPointCount-1]]=5;
				m_nAllowedPoint[end_NO]=0;
			}
		}
		m_nPath_No[m_nMovedPointCount-1]=nPointNo;
		m_nPath[m_nMovedPointCount-1]=nPointNo;//把这个城市设置成已经去过了
		m_nCurPointNo=m_nPath_No[m_nMovedPointCount-2];
		
		m_nMovedPointCount--;
		Back_Flag=false;
		if(m_nPath_No[0]==-1)
		{
			Stop_Flag=true;
			Death_Flag=true;
		}
	}
	for(int i=0;i<N_POINT_COUNT;i++)
	{
		if(m_nAllowedPoint[i]>1)
		{
			m_nAllowedPoint[i]--;
		}
	}
	
}

//蚂蚁进行搜索一次
void CAnt::Search()
{
    Init(); //蚂蚁搜索前，先初始化

    //如果蚂蚁去过的城市数量小于城市数量，就继续移动
    while ((m_nMovedPointCount < N_POINT_COUNT)&&(Stop_Flag==false))
    {
        Move();
     }
	
    //完成搜索后计算走过的路径长度

	if(Death_Flag)
	{
		m_dbPathLength=0xFFFF;
	}
	else
	{
		CalPathLength();
	}
	
	
    
}


//计算蚂蚁走过的路径长度
void CAnt::CalPathLength()
{

    m_dbPathLength=0.0; //先把路径长度置0
    int m=0;
    int n=0;

    for (int i=1;i<N_POINT_COUNT;i++)
    {
		if(m=m_nPath_No[i]!=-1)
		{
			m=m_nPath_No[i];
			n=m_nPath_No[i-1];
			m_dbPathLength=m_dbPathLength+g_Cost[n][m];
		}
        
    }

    //加上从最后城市返回出发城市的距离
    //n=m_nPath[0];
    //m_dbPathLength=m_dbPathLength+g_Cost[m][n];    

}




//tsp类
class CTsp
{
public:
    CTsp(void);
    ~CTsp(void);

public:
    CAnt m_cAntAry[N_ANT_COUNT]; //蚂蚁数组
    CAnt m_cBestAnt; //定义一个蚂蚁变量，用来保存搜索过程中的最优结果
                                        //该蚂蚁不参与搜索，只是用来保存最优结果

public:

    //初始化数据
    void InitData(); 

    //开始搜索
    void Search(); 

    //更新环境信息素
    void UpdateTrial();


};


//构造函数
CTsp::CTsp(void)
{
}

CTsp::~CTsp(void)
{
}


//初始化数据
void CTsp::InitData() 
{

    //先把最优蚂蚁的路径长度设置成一个很大的值
    m_cBestAnt.m_dbPathLength=DB_MAX; 

    //计算两两城市间距离
	/*
    double dbTemp=0.0;
    for (int i=0;i<N_POINT_COUNT;i++)
    {
        for (int j=0;j<N_POINT_COUNT;j++)
        {
            dbTemp=(x_Ary[i]-x_Ary[j])*(x_Ary[i]-x_Ary[j])+(y_Ary[i]-y_Ary[j])*(y_Ary[i]-y_Ary[j]);
            dbTemp=pow(dbTemp,0.5);
            g_Cost[i][j]=ROUND(dbTemp);
        }
    }
	*/

    //初始化环境信息素，先把城市间的信息素设置成一样
    //这里设置成1.0，设置成多少对结果影响不是太大，对算法收敛速度有些影响
    for (int i=0;i<N_POINT_COUNT;i++)
    {
        for (int j=0;j<N_POINT_COUNT;j++)
        {
			if(g_Cost[i][j]!=-1)
			{
				g_Trial[i][j]=1.0;
			}
			else
			{
				g_Trial[i][j]=0.0;
			}
            
        }
    }

}

//更新环境信息素
void CTsp::UpdateTrial()
{
    //临时数组，保存各只蚂蚁在两两城市间新留下的信息素
    double dbTempAry[N_POINT_COUNT][N_POINT_COUNT];
    memset(dbTempAry,0,sizeof(dbTempAry)); //先全部设置为0

    //计算新增加的信息素,保存到临时数组里
    int m=0;
    int n=0;
	int Path_num=0;
	/*
	for(int i=0;i<N_POINT_COUNT;i++)
	{
		for(int j=0;j<N_POINT_COUNT;j++)
		{
			dbTempAry[i][j]=0.0;
		}
	}
	*/
    for (int i=0;i<N_ANT_COUNT;i++) //计算每只蚂蚁留下的信息素
    {
		for(int j=1;j<N_POINT_COUNT;j++)
		{
			if(m_cAntAry[i].m_nPath[j]==-1)
			{
				Path_num=j;
				break;
			}
			if(j==N_POINT_COUNT-1)
			{
				Path_num=N_POINT_COUNT;
				break;
			}
		}

        for (int j=1;j<Path_num;j++)
        {
            m=m_cAntAry[i].m_nPath_No[j];
            n=m_cAntAry[i].m_nPath_No[j-1];
            dbTempAry[n][m]+=DBQ/m_cAntAry[i].m_dbPathLength;
            //dbTempAry[m][n]=dbTempAry[n][m];
        }

            //最后城市和开始城市之间的信息素
        //n=m_cAntAry[i].m_nPath[0];
        //dbTempAry[n][m]=dbTempAry[n][m]+DBQ/m_cAntAry[i].m_dbPathLength;
        //dbTempAry[m][n]=dbTempAry[n][m];

    }

    //==================================================================
    //更新环境信息素
    for (int i=0;i<N_POINT_COUNT;i++)
    {
        for (int j=0;j<N_POINT_COUNT;j++)
        {
            g_Trial[i][j]=g_Trial[i][j]*ROU+dbTempAry[i][j]; //最新的环境信息素 = 留存的信息素 + 新留下的信息素
        }
    }

}


void CTsp::Search()
{

    char cBuf[256]; //打印信息用

    //在迭代次数内进行循环
    for (int i=0;i<N_IT_COUNT;i++)
    {
        //每只蚂蚁搜索一遍
        for (int j=0;j<N_ANT_COUNT;j++)
        {
            m_cAntAry[j].Search(); 
        }

        //保存最佳结果
        for (int j=0;j<N_ANT_COUNT;j++)
        {
            if (m_cAntAry[j].m_dbPathLength < m_cBestAnt.m_dbPathLength)
            {
                m_cBestAnt=m_cAntAry[j];
            }
        }

        //更新环境信息素
        UpdateTrial();

        //输出目前为止找到的最优路径的长度

		if(m_cBestAnt.m_dbPathLength==0xFFFF)
		{
			sprintf_s(cBuf,"\n[%d] %s",i+1,"NA");
			printf(cBuf);
		}
		else
		{
			sprintf_s(cBuf,"\n[%d] %.0f",i+1,m_cBestAnt.m_dbPathLength);
			printf(cBuf);
		}
		
	}
        
}



int main()
{
    //用当前时间点初始化随机种子，防止每次运行的结果都相同
    time_t tm;
    time(&tm);
    unsigned int nSeed=(unsigned int)tm;
    srand(nSeed);

    //开始搜索
    CTsp tsp;

    tsp.InitData(); //初始化
    tsp.Search(); //开始搜索

	if(tsp.m_cBestAnt.m_dbPathLength==0xFFFF)
	{
		printf("\n未找到合适路径");
	}
	else
	{
		printf("\nThe best tour is :\n");

		char cBuf[128];
		for (int i=0;i<N_POINT_COUNT;i++)
		{
			if(tsp.m_cBestAnt.m_nPath[i]!=-1)
			{
				sprintf_s(cBuf,"%02d ",tsp.m_cBestAnt.m_nPath[i]);
			}
			else
			{
				break;
			}
        
			if (i % 20 == 0)
			{
				printf("\n");
			}
			printf(cBuf);
		}
	}
		
	
    //输出结果

    

    printf("\n\nPress any key to exit!");
    getchar();

    return 0;
}



