// myant.cpp : 定义控制台应用程序的入口点。
//

// AO.cpp : 定义控制台应用程序的入口点。
#pragma once
#include "stdafx.h"
#include <iostream>
#include <math.h>
#include <time.h>

const double ALPHA=1.0; //启发因子，信息素的重要程度
const double BETA=2.0;   //期望因子，城市间距离的重要程度
const double ROU=0.5; //信息素残留参数

const double Pbest=0.05; //蚂蚁一次搜索找到最优路径的概率


const int N_ANT_COUNT=2; //蚂蚁数量
const int N_IT_COUNT=100; //迭代次数
const int N_POINT_COUNT=20; //城市数量

const int N_POINT_NO[N_POINT_COUNT]={0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19};
const int N_POINT_SELF_ID[N_POINT_COUNT]={0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19};//节点自身ID
const int N_START_POINT_SELF_ID=2 ;  //出发城市IDg_Prob
const int N_END_POINT_SELF_ID= 19;  //终点城市ID
const int N_INCLUDING_SELF_ID[]={3,5,7,11,13,17};        //必经节点ID

const double DBQ=100.0; //总的信息素
const double DB_MAX=10e9; //一个标志数，10的9次方


double g_Prob[N_POINT_COUNT][N_POINT_COUNT];
int rnd(int nLow,int nUpper); //返回随机数
double rnd(double dbLow,double dbUpper);
double ROUND(double dbA);
double g_CostBeta[N_POINT_COUNT][N_POINT_COUNT];


double g_Trial[N_POINT_COUNT][N_POINT_COUNT]; //两两城市间信息素，就是环境信息素
double g_Cost[N_POINT_COUNT][N_POINT_COUNT]={
//    0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19
	{-1,-1,-1,-1, 8,-1,-1,-1,17,-1,-1,-1,-1,15,-1,-1,-1,-1,-1, 1},//0
	{ 4,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},//1
	{-1,-1,-1,20,-1,-1,-1,-1,-1,19,-1,-1,-1,-1,-1, 8,-1,-1,-1,-1},//2
	{14,-1,-1,-1,-1,20,-1,-1,-1,-1,-1,12,-1,-1,-1,-1,-1,-1,-1,-1},//3
	{-1,15,-1,-1,-1,17,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},//4
	{-1,-1,-1,-1,-1,-1, 2,20,18,14,-1,-1,-1,-1,-1,-1,-1,-1,-1,20},//5
	{-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 4,-1,-1},//6
	{-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,20,-1, 1,-1,-1,19,-1,-1,-1},//7
	{-1,-1,-1,-1,-1,-1, 1,-1,-1,-1,-1,-1,17,-1,-1,-1,-1,-1,-1,-1},//8
	{-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,11,-1,-1,-1,-1,-1},//9
	{-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 1,-1,-1,-1,-1,-1,-1,-1},//10
	{-1,-1,-1,-1, 7,-1,-1,12,-1,-1,-1,-1,-1,20,-1,-1,-1,-1,-1,20},//11
	{-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 5,-1,-1,-1,-1,-1},//12
	{-1,-1,-1,-1, 2,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,12,-1,-1},//13
	{-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 9},//14
	{-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,14,-1,-1,-1,-1,-1,-1,-1, 2,-1},//15
	{-1,-1,-1,-1,-1,-1,-1,-1, 1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},//16
	{-1,-1,-1,-1,-1,20,-1,-1,-1,14,-1,20,-1,-1,-1,-1,-1,-1,10, 3},//17
	{-1,-1,-1, 8,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 8,-1,-1,-1,-1},//18
	{-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,12,-1} //19
//    0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19

}; //两两城市间距离

//eil51.tsp城市坐标数据


//返回指定范围内的随机整数
int rnd(int nLow,int nUpper)
{
    return nLow+(nUpper-nLow)*rand()/(RAND_MAX+1);
}

//返回指定范围内的随机浮点数
double rnd(double dbLow,double dbUpper)
{
    double dbTemp=rand()/((double)RAND_MAX+1.0);
    return dbLow+dbTemp*(dbUpper-dbLow);
}

//返回浮点数四舍五入取整后的浮点数
double ROUND(double dbA)
{
    return (double)((int)(dbA+0.5));
}





//定义蚂蚁类
class CAnt
{
public:
    CAnt(void);
    ~CAnt(void);

public:

	int m_nPath[N_POINT_COUNT]; //蚂蚁走的自身ID路径
	int m_nPath_No[N_POINT_COUNT]; //蚂蚁编号路径
    double m_dbPathLength; //蚂蚁走过的路径长度

    int m_nAllowedPoint[N_POINT_COUNT]; //没去过的城市
    int m_nCurPointNo; //当前所在城市编号
    int m_nMovedPointCount; //已经去过的城市数量
	int end_NO;//终点城市编号
	bool Stop_Flag;
	bool Back_Flag;

	bool m_blGreedSearch; //是否使用贪心原则选择下一城市


public:

    int ChooseNextPoint(); //选择下一个城市

	int GreedChooseNextCity(); //贪心原则选择下一个城市

    void Init(); //初始化
    void Move(); //蚂蚁在城市间移动
    void Search(); //搜索路径
    void CalPathLength(); //计算蚂蚁走过的路径长度

};

//构造函数
CAnt::CAnt(void)
{
}

//析构函数
CAnt::~CAnt(void)
{
}





//初始化函数，蚂蚁搜索前调用
void CAnt::Init()
{
	for(int i=0;i<N_POINT_COUNT;i++)
	{
		if(N_POINT_SELF_ID[i]==N_START_POINT_SELF_ID)
		{
			m_nCurPointNo=i;
			//break;
		}
		if(N_POINT_SELF_ID[i]==N_END_POINT_SELF_ID)
		{
			end_NO=i;
		}
		
	}

    for (int i=0;i<N_POINT_COUNT;i++)
    {
		if(i==end_NO)
		{
			m_nAllowedPoint[i]=0;
		}
		else
		{
			m_nAllowedPoint[i]=1; //设置全部城市为没有去过
		}
        m_nPath[i]=-1; //蚂蚁走的路径全部设置为0
		m_nPath_No[i]=-1;
    }

    //蚂蚁走过的路径长度设置为0
    m_dbPathLength=0.0; 

    //随机选择一个出发城市
	
    //m_nCurPointNo=N_START_POINT_SELF_ID;
    //把出发城市保存入路径数组中
	m_nPath_No[0]=m_nCurPointNo;
    m_nPath[0]=N_START_POINT_SELF_ID;

    //标识出发城市为已经去过了
    m_nAllowedPoint[m_nCurPointNo]=0; 

    //已经去过的城市数量设置为1
    m_nMovedPointCount=1; 
	Stop_Flag=false;
	
	Back_Flag=false;
	//不使用贪心原则选择下一城市
	m_blGreedSearch=false;
}


// 贪心原则选择下一个城市
int CAnt::GreedChooseNextCity()
{
	int nSelectedCity=-1; //返回结果，先暂时把其设置为-1
	double dbLen=DB_MAX;

	for (int i=0;i<N_POINT_COUNT;i++)
	{
		//新增3
		if ((m_nAllowedPoint[i] == 1) && (g_Cost[m_nCurPointNo][i]!=-1)) //城市没去过
		{
			if ((g_Cost[m_nCurPointNo][i] < dbLen)&&(g_Cost[m_nCurPointNo][i] !=-1))
			{
				dbLen=g_Cost[m_nCurPointNo][i];
				nSelectedCity=i;
			}
		}
	}
	//新增5
	if(nSelectedCity==-1)
	{
		Back_Flag=true;

	}
	return nSelectedCity;
}


//选择下一个城市
//返回值 为城市编号
int CAnt::ChooseNextPoint()
{

    int nSelectedPoint=-1; //返回结果，先暂时把其设置为-1

    //==============================================================================
    //计算当前城市和没去过的城市之间的信息素总和
    
    double dbTotal=0.0;    
    double prob[N_POINT_COUNT]; //保存各个城市被选中的概率

    for (int i=0;i<N_POINT_COUNT;i++)
    {
        if ((m_nAllowedPoint[i] == 1) && (g_Cost[m_nCurPointNo][i]!=-1)) //城市没去过
        {
       //   prob[i]=pow(g_Trial[m_nCurPointNo][i],ALPHA)*pow(1.0/g_Cost[m_nCurPointNo][i],BETA); //该城市和当前城市间的信息素
			prob[i]=g_Prob[m_nCurPointNo][i];
            dbTotal=dbTotal+prob[i]; //累加信息素，得到总和
        }
        else //如果城市去过了，则其被选中的概率值为0
        {
            prob[i]=0.0;
        }
    }
	for(int i=0;i<N_POINT_COUNT;i++)
	{
		if(prob[i]>0)
		{
			break;
		}
		if(i==N_POINT_COUNT-1)
		{

			//Stop_Flag=true;
			Back_Flag=true;
		}
	}

    //==============================================================================
    //进行轮盘选择
    double dbTemp=0.0;

    if ((dbTotal > 0.0)&&(Back_Flag==false)) //总的信息素值大于0
    {
        dbTemp=rnd(0.0,dbTotal); //取一个随机数

        for (int i=0;i<N_POINT_COUNT;i++)
        {
            if ((m_nAllowedPoint[i] == 1) && (g_Cost[m_nCurPointNo][i]!=-1)) //城市没去过
            {
                dbTemp=dbTemp-prob[i]; //这个操作相当于转动轮盘，如果对轮盘选择不熟悉，仔细考虑一下
                if (dbTemp < 0.0) //轮盘停止转动，记下城市编号，直接跳出循环
				{
                    nSelectedPoint=i;
                    break;
                }
            }
        }
    }

    //==============================================================================
    //如果城市间的信息素非常小 ( 小到比double能够表示的最小的数字还要小 )
    //那么由于浮点运算的误差原因，上面计算的概率总和可能为0
    //会出现经过上述操作，没有城市被选择出来
    //出现这种情况，就把第一个没去过的城市作为返回结果
    
    //题外话：刚开始看的时候，下面这段代码困惑了我很长时间，想不通为何要有这段代码，后来才搞清楚。
    
	
    //==============================================================================
    //返回结果，就是城市的编号
    return nSelectedPoint;
}





//蚂蚁在城市间移动
void CAnt::Move()
{


    int nPointNo=0; //选择下一个城市
	if (m_blGreedSearch == true)
		nPointNo=GreedChooseNextCity(); 
	else
		nPointNo=ChooseNextPoint();



	if(Back_Flag==false)
	{
		bool flag=false;
		
		m_nPath_No[m_nMovedPointCount]=nPointNo;
		m_nPath[m_nMovedPointCount]=N_POINT_SELF_ID[nPointNo];
		/*
		for(int i=0;i<N_POINT_COUNT;i++)
		{
			if(N_POINT_NO[i]==nPointNo)
			{
				m_nPath[m_nMovedPointCount]=N_POINT_SELF_ID;
				break;
			}
		}
		*/
		//m_nPath[m_nMovedPointCount]=nPointNo; //保存蚂蚁走的路径
		m_nAllowedPoint[nPointNo]=0;//把这个城市设置成已经去过了
		m_nCurPointNo=nPointNo; //改变当前所在城市为选择的城市
		m_nMovedPointCount++; //已经去过的城市数量加1
		for(int i=0;i<sizeof(N_INCLUDING_SELF_ID)/sizeof(N_INCLUDING_SELF_ID[0]);i++)
		{
			for(int j=0;j<N_POINT_COUNT;j++)
			{
				if(N_INCLUDING_SELF_ID[i]==m_nPath[j])
				{
					break;
				}
				if(j==N_POINT_COUNT-1)
				{
					flag=true;
				}
			
			}
			if(flag)
			{
				break;
			}
			if(i==sizeof(N_INCLUDING_SELF_ID)/sizeof(N_INCLUDING_SELF_ID[0])-1)
			{
				m_nAllowedPoint[end_NO]=1;
			}
		}
		if(nPointNo==end_NO)
		{
			Stop_Flag=true;
		}
	}
	//新增4
	else
	{
		m_nAllowedPoint[m_nPath_No[m_nMovedPointCount-1]]=0;
		m_nPath_No[m_nMovedPointCount-1]=nPointNo;
		m_nPath[m_nMovedPointCount-1]=nPointNo;//把这个城市设置成已经去过了
		m_nCurPointNo=m_nPath_No[m_nMovedPointCount-2];
		m_nMovedPointCount--;
		Back_Flag=false;
	}
	
}

//蚂蚁进行搜索一次
void CAnt::Search()
{
	//新增1
	if(m_blGreedSearch==false)
		Init(); //蚂蚁搜索前，先初始化

    //如果蚂蚁去过的城市数量小于城市数量，就继续移动
    while ((m_nMovedPointCount < N_POINT_COUNT)&&(Stop_Flag==false))
    {
        Move();
    }

    //完成搜索后计算走过的路径长度
	//新增
	CalPathLength();

    
}


//计算蚂蚁走过的路径长度
void CAnt::CalPathLength()
{

    m_dbPathLength=0.0; //先把路径长度置0
    int m=0;
    int n=0;

    for (int i=1;i<N_POINT_COUNT;i++)
    {
		//新增cost
		if(m_nPath_No[i]!=-1)
		{
			m=m_nPath_No[i];
			n=m_nPath_No[i-1];
			m_dbPathLength=m_dbPathLength+g_Cost[n][m];
		}
        
    }

    //加上从最后城市返回出发城市的距离
    //n=m_nPath[0];
    //m_dbPathLength=m_dbPathLength+g_Cost[m][n];    

}




//tsp类
class CTsp
{
public:
    CTsp(void);
    ~CTsp(void);

public:
    CAnt m_cAntAry[N_ANT_COUNT]; //蚂蚁数组
    CAnt m_cBestAnt; //定义一个蚂蚁变量，用来保存搜索过程中的最优结果
                                        //该蚂蚁不参与搜索，只是用来保存最优结果
	
	
	
	double m_dbRate; //最大信息素和最小信息素的比值

public:

    //初始化数据
    void InitData(); 

    //开始搜索
    void Search(); 

    //更新环境信息素
    void UpdateTrial();


};


//构造函数
CTsp::CTsp(void)
{
	
}

CTsp::~CTsp(void)
{
}


//初始化数据
void CTsp::InitData() 
{

    //先把最优蚂蚁的路径长度设置成一个很大的值
    m_cBestAnt.m_dbPathLength=DB_MAX; 

    //计算两两城市间距离
	/*
    double dbTemp=0.0;
    for (int i=0;i<N_POINT_COUNT;i++)
    {
        for (int j=0;j<N_POINT_COUNT;j++)
        {
            dbTemp=(x_Ary[i]-x_Ary[j])*(x_Ary[i]-x_Ary[j])+(y_Ary[i]-y_Ary[j])*(y_Ary[i]-y_Ary[j]);
            dbTemp=pow(dbTemp,0.5);
            g_Cost[i][j]=ROUND(dbTemp);
        }
    }
	*/

	for (int i=0;i<N_POINT_COUNT;i++)
    {
        for (int j=0;j<N_POINT_COUNT;j++)
        {
			if(g_Cost[i][j]!=-1)
			{
				g_CostBeta[i][j]=pow(1.0/g_Cost[i][j],BETA);
			}
			else
			{
				g_CostBeta[i][j]=-1;
			}
				
		}
	}
	//用贪心算法生成最开始的解
	m_cBestAnt.Init();
	m_cBestAnt.m_blGreedSearch=true;
	m_cBestAnt.Search();
	double Imax=1.0/(m_cBestAnt.m_dbPathLength*(1.0-ROU));
	// 初始化环境信息素
    for (int i=0;i<N_POINT_COUNT;i++)
    {
        for (int j=0;j<N_POINT_COUNT;j++)
        {
			if(g_Cost[i][j]!=-1)
			{
				g_Trial[i][j]=Imax;

				g_Prob[i][j]=pow(Imax,ALPHA)*g_CostBeta[i][j];
			}
			else
			{
				g_Trial[i][j]=0.0;
				g_Prob[i][j]=0.0;
			}
            
        }
    }
	//计算最大和最小信息素之间的比值
	//dbTemp=pow(Pbest,1.0/(double)N_CITY_COUNT); //对Pbest开N_CITY_COUNT次方
	double dbTemp=0.0;
	dbTemp=exp(log(Pbest)/(double)N_POINT_COUNT); //对Pbest开N_CITY_COUNT次方
	double dbFz=2.0*(1.0-dbTemp);
	double dbFm=((double)N_POINT_COUNT-2.0)*dbTemp;
	m_dbRate=dbFz/dbFm;
}

//更新环境信息素
void CTsp::UpdateTrial()
{
    //临时数组，保存各只蚂蚁在两两城市间新留下的信息素
    double dbTempAry[N_POINT_COUNT][N_POINT_COUNT];
    memset(dbTempAry,0,sizeof(dbTempAry)); //先全部设置为0

    //计算新增加的信息素,保存到临时数组里
    int m=0;
    int n=0;
	int Path_num=0;
	/*
	for(int i=0;i<N_POINT_COUNT;i++)
	{
		for(int j=0;j<N_POINT_COUNT;j++)
		{
			dbTempAry[i][j]=0.0;
		}
	}
	*/
    for (int i=0;i<N_ANT_COUNT;i++) //计算每只蚂蚁留下的信息素
    {
		for(int j=1;j<N_POINT_COUNT;j++)
		{
			if(m_cAntAry[i].m_nPath[j]==-1)
			{
				Path_num=j;
				break;
			}
			if(j==N_POINT_COUNT-1)
			{
				Path_num=N_POINT_COUNT;
				break;
			}
		}

        for (int j=1;j<Path_num;j++)
        {
            m=m_cBestAnt.m_nPath[j];
			n=m_cBestAnt.m_nPath[j-1];
			dbTempAry[n][m]=dbTempAry[n][m]+1.0/m_cBestAnt.m_dbPathLength;			
            //dbTempAry[m][n]=dbTempAry[n][m];
        }

            //最后城市和开始城市之间的信息素
        //n=m_cAntAry[i].m_nPath[0];
        //dbTempAry[n][m]=dbTempAry[n][m]+DBQ/m_cAntAry[i].m_dbPathLength;
        //dbTempAry[m][n]=dbTempAry[n][m];

    }

    //==================================================================
    //更新环境信息素
    for (int i=0;i<N_POINT_COUNT;i++)
    {
        for (int j=0;j<N_POINT_COUNT;j++)
        {
            g_Trial[i][j]=g_Trial[i][j]*ROU+dbTempAry[i][j]; //最新的环境信息素 = 留存的信息素 + 新留下的信息素
        }
    }
		//==================================================================
	//检查环境信息素，如果在最小和最大值的外面，则将其重新调整
	double Imax=1.0/(m_cBestAnt.m_dbPathLength*(1.0-ROU));
	double Imin=Imax*m_dbRate;

	for (int i=0;i<N_POINT_COUNT;i++)
	{
		for (int j=0;j<N_POINT_COUNT;j++)
		{
			if (g_Trial[i][j] < Imin)
			{
				g_Trial[i][j] = Imin;
			}

			if (g_Trial[i][j] > Imax)
			{
				g_Trial[i][j] = Imax;
			}

		}
	}


	for (int i=0;i<N_POINT_COUNT;i++)
	{
		for (int j=0;j<N_POINT_COUNT;j++)
		{
			if(g_Cost[i][j]!=-1)
			{
				g_Prob[i][j]=pow(g_Trial[i][j],ALPHA)*g_CostBeta[i][j];
			}
			else
			{
				g_Prob[i][j]=0.0;
			}
		}
	}
}


void CTsp::Search()
{

    char cBuf[256]; //打印信息用

    //在迭代次数内进行循环
    for (int i=0;i<N_IT_COUNT;i++)
    {
        //每只蚂蚁搜索一遍
        for (int j=0;j<N_ANT_COUNT;j++)
        {
			//新增2
			m_cAntAry[j].m_blGreedSearch==false;
            m_cAntAry[j].Search(); 
        }

        //保存最佳结果
        for (int j=0;j<N_ANT_COUNT;j++)
        {
            if (m_cAntAry[j].m_dbPathLength < m_cBestAnt.m_dbPathLength)
            {
                m_cBestAnt=m_cAntAry[j];
            }
        }

        //更新环境信息素
        UpdateTrial();

        //输出目前为止找到的最优路径的长度
	
			sprintf_s(cBuf,"\n[%d] %.0f",i+1,m_cBestAnt.m_dbPathLength);
			printf(cBuf);
		
        
    }

}

int main()
{
    //用当前时间点初始化随机种子，防止每次运行的结果都相同
    time_t tm;
    time(&tm);
    unsigned int nSeed=(unsigned int)tm;
    srand(nSeed);

    //开始搜索
    CTsp tsp;

    tsp.InitData(); //初始化
    tsp.Search(); //开始搜索
	/*
	if(tsp.m_cBestAnt.m_dbPathLength==0xFFFF)
	{
		printf("没有找到最优路径");
	}
	else
	{
	*/
		printf("\nThe best tour is :\n");

		char cBuf[128];
		for (int i=0;i<N_POINT_COUNT;i++)
		{
			if(tsp.m_cBestAnt.m_nPath[i]!=-1)
			{
				sprintf_s(cBuf,"%02d ",tsp.m_cBestAnt.m_nPath[i]);
			}
			else
			{
				break;
			}
        
			if (i % 20 == 0)
			{
				printf("\n");
			}
			printf(cBuf);
		}

	//}
    //输出结果

    

    printf("\n\nPress any key to exit!");
    getchar();

    return 0;
}



